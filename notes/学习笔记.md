# 函数式编程

## 概念
- 函数式编程中的函数指的不是程序中的函数(方法)，而是数学中的函数即映射关系，例如：y = six(x)，x和y的关系
- 函数式编程用来描述数据(函数)之间的**映射**

## 函数是一等公民 /First-class Function（头等函数）
- 把函数赋值给变量
- 传递一个函数作为参数
- 返回一个函数

在 JavaScript 中函数就是一个普通对象，我们可以把函数储存到变量/数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过 new Function() 来构造一个新的函数

## 高阶函数
- 抽象可以帮助我们屏蔽细节，只需要关注于我们的目标
- 高阶函数是用来抽象通用问题

## 闭包
- 函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包。
- 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员
- 函数在执行的时候回放到一个执行栈上，当函数执行完毕之后回从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员

## 纯函数
- 纯函数概念：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用
- 纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，y=f(x)
- lodash 是一个纯函数的功能库，提供了对数组、数字、字符串、函数等操作的一些方法
- 数组的 slice 和 splice 分别是：纯函数和非纯函数

## 柯里化
- 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
- 然后返回一个新的函数接收剩余的参数，返回结果



- 可以让外面给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
- 对函数参数进行‘缓存’
- 闭包、递归；判断实参与形参的数量是否相等，如果相等直接返回func执行结果，如果不相等，递归调用自身，之前传入的参数通过闭包保存下来了，之前的实参与后续的实参相加继续与形参相比，如此循环。
```
function curry(func){
    return function curriedFn(...args){
        // 判断实参和形参的个数
        if(args.length < func.length){
            return function(){
                return curriedFn(...args.concat(Array.from(arguments)))
            }
        }
        return func(...args)
    }
}
```

# JavaScript 性能优化

## 垃圾回收
- JavaScript 中内存管理是自动的
- 对象不再被引用时是垃圾
- 对象不能从根上访问到时是垃圾


## 可达对象
- 可以访问到对象就是可达对象（引用、作用域链）
- 可达的标准就是从根出发是否能够被找到
- JavaScript 中的根就可以理解为是全局变量对象

## GC算法
- GC 就是垃圾回收机制的简写
- GC 可以找到内存中的垃圾、并释放和回收空间

常见 GC 算法
- 引用计数
- 标记清除
- 标记整理
- 分代回收

## 频繁的垃圾回收
- GC 工作时应用程序是停止的
- 频繁且过长的 GC 会导致应用假死
- 用户使用中感知应用卡顿

### 引用计数算法
- 核心思想：设置引用数，判断当前引用数是否为0
- 引用计数器，引用关系改变时修改引用数字，引用数字为0时立即回收

#### 优点
- 发现垃圾时立即回收
- 最大限度减少程序暂停

#### 缺点
- 无法回收循环引用的对象
- 资源消耗大、时间开销大


### 标记清除算法
- 核心思想：分标记和清除两个阶段完成
- 遍历所有对象找标记活动对象
- 遍历所有对象清除没有标记对象
- 回收相应的空间

优点：能用清除循环引用
缺点：内存释放后的空间碎片化，浪费空间，不会立即回收垃圾对象

### 标记整理算法
- 标记整理可以看做是标记清除的增强
- 标记阶段的操作和标记清除一致
- 清除阶段会先执行整理，移动对象位置
- 减少碎片化空间
- 也不能立即回收垃圾对象




## V8
- V8 是一款主流的 JavaScript 执行引擎
- V8 采用即使编译
- V8 内存设限(为浏览器设限、过大导致时间过长)
- V8 采用基于分代回收思想实现垃圾回收
- V8 内存分为新生代和老生代

### V8 垃圾回收策略
- 采用分代回收的思想
- 内存分为新生代、老生代
- 针对不同对象采用不同算法


## 新生代对象回收实现
- 回收过程采用复制算法+标记整理
- 新生代内存区分为两个等大小空间
- 使用空间为From 空闲空间为 To
- 活动对象存储于 From 空间
- 标记整理后将活动对象拷贝至 To
- From 与 To 交换空间完成释放

## 老生代对象回收实现
- 主要采用标记清除、标记整理、增量标记算法
- 首先使用标记清除完成垃圾空间的回收
- 采用标记整理进行空间优化
- 采用增量标记进行效率优化

## 对比
- 新生代区域垃圾回收使用空间换时间
- 老生代区域垃圾回收不适合复制算法

## 界定内存问题的标准
- 内存泄漏：内存使用持续升高
- 内存膨胀：在多数设备上都存在性能问题
- 频繁垃圾回收：通过内存变化图进行分析

## 

## 代码优化
- 测试运行速度工具网站 https://jsperf.com/


- 慎用全局变量
- 缓存全局变量
- 原型对象比在构造器中更快

### 慎用全局变量
- 全局变量定义在全局执行上下文，是所有作用域链的顶端
- 全局执行上下文一直存在于上下文执行栈，直到程序退出
- 如果某个局部作用域出现了同名变量则会遮蔽或污染全局

